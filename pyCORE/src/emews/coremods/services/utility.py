"""
utility.py: defines miscellaneous utility services.
"""

import os
import subprocess

from core import constants
from core.misc import utils
from core.misc.ipaddress import Ipv4Prefix
from core.misc.ipaddress import Ipv6Prefix
from core.service import CoreService


class UtilService(CoreService):
    """
    Parent class for utility services.
    """
    _name = "UtilityProcess"
    _group = "Utility"
    _depends = ()
    _dirs = ()
    _configs = ()
    _startindex = 80
    _startup = ()
    _shutdown = ()

    @classmethod
    def generateconfig(cls, node, filename, services):
        return ""


class IPForwardService(UtilService):
    _name = "IPForward"
    _configs = ("ipforward.sh",)
    _startindex = 5
    _startup = ("sh ipforward.sh",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        if os.uname()[0] == "Linux":
            return cls.generateconfiglinux(node, filename, services)
        elif os.uname()[0] == "FreeBSD":
            return cls.generateconfigbsd(node, filename, services)
        else:
            raise Exception, "unknown platform"

    @classmethod
    def generateconfiglinux(cls, node, filename, services):
        cfg = """\
#!/bin/sh
# auto-generated by IPForward service (utility.py)
%(sysctl)s -w net.ipv4.conf.all.forwarding=1
%(sysctl)s -w net.ipv4.conf.default.forwarding=1
%(sysctl)s -w net.ipv6.conf.all.forwarding=1
%(sysctl)s -w net.ipv6.conf.default.forwarding=1
%(sysctl)s -w net.ipv4.conf.all.send_redirects=0
%(sysctl)s -w net.ipv4.conf.default.send_redirects=0
%(sysctl)s -w net.ipv4.conf.all.rp_filter=0
%(sysctl)s -w net.ipv4.conf.default.rp_filter=0
""" % {'sysctl': constants.SYSCTL_BIN}
        for ifc in node.netifs():
            name = utils.sysctldevname(ifc.name)
            cfg += "%s -w net.ipv4.conf.%s.forwarding=1\n" % (constants.SYSCTL_BIN, name)
            cfg += "%s -w net.ipv4.conf.%s.send_redirects=0\n" % \
                   (constants.SYSCTL_BIN, name)
            cfg += "%s -w net.ipv4.conf.%s.rp_filter=0\n" % (constants.SYSCTL_BIN, name)
        return cfg

    @classmethod
    def generateconfigbsd(cls, node, filename, services):
        return """\
#!/bin/sh
# auto-generated by IPForward service (utility.py)
%s -w net.inet.ip.forwarding=1
%s -w net.inet6.ip6.forwarding=1
%s -w net.inet.icmp.bmcastecho=1
%s -w net.inet.icmp.icmplim=0
""" % (constants.SYSCTL_BIN, constants.SYSCTL_BIN, constants.SYSCTL_BIN, constants.SYSCTL_BIN)


class DefaultRouteService(UtilService):
    _name = "DefaultRoute"
    _configs = ("defaultroute.sh",)
    _startup = ("sh defaultroute.sh",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        cfg = "#!/bin/sh\n"
        cfg += "# auto-generated by DefaultRoute service (utility.py)\n"
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control is True:
                continue
            cfg += "\n".join(map(cls.addrstr, ifc.addrlist))
            cfg += "\n"
        return cfg

    @staticmethod
    def addrstr(x):
        if x.find(":") >= 0:
            net = Ipv6Prefix(x)
            fam = "inet6 ::"
        else:
            net = Ipv4Prefix(x)
            fam = "inet 0.0.0.0"
        if net.max_addr() == net.min_addr():
            return ""
        else:
            if os.uname()[0] == "Linux":
                rtcmd = "ip route add default via"
            elif os.uname()[0] == "FreeBSD":
                rtcmd = "route add -%s" % fam
            else:
                raise Exception, "unknown platform"
            return "%s %s" % (rtcmd, net.min_addr())


class DefaultMulticastRouteService(UtilService):
    _name = "DefaultMulticastRoute"
    _configs = ("defaultmroute.sh",)
    _startup = ("sh defaultmroute.sh",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        cfg = "#!/bin/sh\n"
        cfg += "# auto-generated by DefaultMulticastRoute service (utility.py)\n"
        cfg += "# the first interface is chosen below; please change it "
        cfg += "as needed\n"

        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control == True:
                continue
            if os.uname()[0] == "Linux":
                rtcmd = "ip route add 224.0.0.0/4 dev"
            elif os.uname()[0] == "FreeBSD":
                rtcmd = "route add 224.0.0.0/4 -iface"
            else:
                raise Exception, "unknown platform"
            cfg += "%s %s\n" % (rtcmd, ifc.name)
            cfg += "\n"
            break
        return cfg


class StaticRouteService(UtilService):
    _name = "StaticRoute"
    _configs = ("staticroute.sh",)
    _startup = ("sh staticroute.sh",)
    _custom_needed = True

    @classmethod
    def generateconfig(cls, node, filename, services):
        cfg = "#!/bin/sh\n"
        cfg += "# auto-generated by StaticRoute service (utility.py)\n#\n"
        cfg += "# NOTE: this service must be customized to be of any use\n"
        cfg += "#       Below are samples that you can uncomment and edit.\n#\n"
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control is True:
                continue
            cfg += "\n".join(map(cls.routestr, ifc.addrlist))
            cfg += "\n"
        return cfg

    @staticmethod
    def routestr(x):
        if x.find(":") >= 0:
            net = Ipv6Prefix(x)
            fam = "inet6"
            dst = "3ffe:4::/64"
        else:
            net = Ipv4Prefix(x)
            fam = "inet"
            dst = "10.9.8.0/24"
        if net.max_addr() == net.min_addr():
            return ""
        else:
            if os.uname()[0] == "Linux":
                rtcmd = "#/sbin/ip route add %s via" % dst
            elif os.uname()[0] == "FreeBSD":
                rtcmd = "#/sbin/route add -%s %s" % (fam, dst)
            else:
                raise Exception, "unknown platform"
            return "%s %s" % (rtcmd, net.min_addr())


class SshService(UtilService):
    _name = "SSH"
    if os.uname()[0] == "FreeBSD":
        _configs = ("startsshd.sh", "sshd_config",)
        _dirs = ()
    else:
        _configs = ("startsshd.sh", "/etc/ssh/sshd_config",)
        _dirs = ("/etc/ssh", "/var/run/sshd",)
    _startup = ("sh startsshd.sh",)
    _shutdown = ("killall sshd",)
    _validate = ()

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Use a startup script for launching sshd in order to wait for host
        key generation.
        """
        if os.uname()[0] == "FreeBSD":
            sshcfgdir = node.nodedir
            sshstatedir = node.nodedir
            sshlibdir = "/usr/libexec"
        else:
            sshcfgdir = cls._dirs[0]
            sshstatedir = cls._dirs[1]
            sshlibdir = "/usr/lib/openssh"
        if filename == "startsshd.sh":
            return """\
#!/bin/sh
# auto-generated by SSH service (utility.py)
ssh-keygen -q -t rsa -N "" -f %s/ssh_host_rsa_key
chmod 655 %s
# wait until RSA host key has been generated to launch sshd
/usr/sbin/sshd -f %s/sshd_config
""" % (sshcfgdir, sshstatedir, sshcfgdir)
        else:
            return """\
# auto-generated by SSH service (utility.py)
Port 22
Protocol 2
HostKey %s/ssh_host_rsa_key
UsePrivilegeSeparation yes
PidFile %s/sshd.pid

KeyRegenerationInterval 3600
ServerKeyBits 768

SyslogFacility AUTH
LogLevel INFO

LoginGraceTime 120
PermitRootLogin no
StrictModes yes

PasswordAuthentication yes
RSAAuthentication yes
PubkeyAuthentication yes

IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no

PermitEmptyPasswords no
ChallengeResponseAuthentication no

X11Forwarding yes
X11DisplayOffset 10
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes

AcceptEnv LANG LC_*
Subsystem sftp %s/sftp-server
UsePAM yes
UseDNS no
""" % (sshcfgdir, sshstatedir, sshlibdir)


class DhcpService(UtilService):
    _name = "DHCP"
    _configs = ("/etc/dhcp/dhcpd.conf",)
    _dirs = ("/etc/dhcp",)
    _startup = ("dhcpd",)
    _shutdown = ("killall dhcpd",)
    _validate = ("pidof dhcpd",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate a dhcpd config file using the network address of
        each interface.
        """
        cfg = """\
# auto-generated by DHCP service (utility.py)
# NOTE: move these option lines into the desired pool { } block(s) below
#option domain-name "test.com";
#option domain-name-servers 10.0.0.1;
#option routers 10.0.0.1;

log-facility local6;

default-lease-time 600;
max-lease-time 7200;

ddns-update-style none;
"""
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control is True:
                continue
            cfg += "\n".join(map(cls.subnetentry, ifc.addrlist))
            cfg += "\n"
        return cfg

    @staticmethod
    def subnetentry(x):
        """
        Generate a subnet declaration block given an IPv4 prefix string
        for inclusion in the dhcpd3 config file.
        """
        if x.find(":") >= 0:
            return ""
        else:
            addr = x.split("/")[0]
            net = Ipv4Prefix(x)
            # divide the address space in half
            rangelow = net.addr(net.num_addr() / 2)
            rangehigh = net.max_addr()
            return """
subnet %s netmask %s {
  pool {
    range %s %s;
    default-lease-time 600;
    option routers %s;
  }
}
""" % (net.prefix_str(), net.netmask_str(), rangelow, rangehigh, addr)


class DhcpClientService(UtilService):
    """
    Use a DHCP client for all interfaces for addressing.
    """
    _name = "DHCPClient"
    _configs = ("startdhcpclient.sh",)
    _startup = ("sh startdhcpclient.sh",)
    _shutdown = ("killall dhclient",)
    _validate = ("pidof dhclient",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate a script to invoke dhclient on all interfaces.
        """
        cfg = "#!/bin/sh\n"
        cfg += "# auto-generated by DHCPClient service (utility.py)\n"
        cfg += "# uncomment this mkdir line and symlink line to enable client-"
        cfg += "side DNS\n# resolution based on the DHCP server response.\n"
        cfg += "#mkdir -p /var/run/resolvconf/interface\n"

        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control == True:
                continue
            cfg += "#ln -s /var/run/resolvconf/interface/%s.dhclient" % ifc.name
            cfg += " /var/run/resolvconf/resolv.conf\n"
            cfg += "/sbin/dhclient -nw -pf /var/run/dhclient-%s.pid" % ifc.name
            cfg += " -lf /var/run/dhclient-%s.lease %s\n" % (ifc.name, ifc.name)
        return cfg


class FtpService(UtilService):
    """
    Start a vsftpd server.
    """
    _name = "FTP"
    _configs = ("vsftpd.conf",)
    _dirs = ("/var/run/vsftpd/empty", "/var/ftp",)
    _startup = ("vsftpd ./vsftpd.conf",)
    _shutdown = ("killall vsftpd",)
    _validate = ("pidof vsftpd",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate a vsftpd.conf configuration file.
        """
        return """\
# vsftpd.conf auto-generated by FTP service (utility.py)
listen=YES
anonymous_enable=YES
local_enable=YES
dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
xferlog_file=/var/log/vsftpd.log
ftpd_banner=Welcome to the CORE FTP service
secure_chroot_dir=/var/run/vsftpd/empty
anon_root=/var/ftp
"""


class HttpService(UtilService):
    """
    Start an apache server.
    """
    _name = "HTTP"
    _configs = ("/etc/apache2/apache2.conf", "/etc/apache2/envvars", "httpd_start.sh",)
    _dirs = ("/etc/apache2", "/var/run/apache2", "/var/log/apache2",
             "/run/lock", "/var/lock/apache2", "/var/run/apache2/ssl",
             "/var/run/apache2/ssl/cert", "/var/run/apache2/ssl/key",)
    _startup = ("chown www-data /var/lock/apache2", "sh httpd_start.sh",)
    _shutdown = ("apache2ctl stop",)
    _validate = ("pidof apache2",)

    APACHEVER22, APACHEVER24 = (22, 24)

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate an apache2.conf configuration file.
        """
        if filename == cls._configs[0]:
            return cls.generateapache2conf(node, filename, services)
        elif filename == cls._configs[1]:
            return cls.generateenvvars(node, filename, services)
        elif filename == cls._configs[2]:
            return cls.generatekeygen(node, filename, services)
        else:
            return ""

    @classmethod
    def detectversionfromcmd(cls):
        """
        Detect the apache2 version using the 'a2query' command.
        """
        try:
            status, result = utils.cmdresult(['a2query', '-v'])
        except subprocess.CalledProcessError:
            status = -1

        if status == 0 and result[:3] == '2.4':
            return cls.APACHEVER24

        return cls.APACHEVER22

    @classmethod
    def generateapache2conf(cls, node, filename, services):
        lockstr = {cls.APACHEVER22:
                       'LockFile ${APACHE_LOCK_DIR}/accept.lock\n',
                   cls.APACHEVER24:
                       'Mutex file:${APACHE_LOCK_DIR} default\n', }
        mpmstr = {cls.APACHEVER22: '', cls.APACHEVER24:
            'LoadModule mpm_worker_module /usr/lib/apache2/modules/mod_mpm_worker.so\n', }

        permstr = {cls.APACHEVER22:
                       '    Order allow,deny\n    Deny from all\n    Satisfy all\n',
                   cls.APACHEVER24:
                       '    Require all denied\n', }

        authstr = {cls.APACHEVER22:
                       'LoadModule authz_default_module /usr/lib/apache2/modules/mod_authz_default.so\n',
                   cls.APACHEVER24:
                       'LoadModule authz_core_module /usr/lib/apache2/modules/mod_authz_core.so\n', }

        permstr2 = {cls.APACHEVER22:
                        '\t\tOrder allow,deny\n\t\tallow from all\n',
                    cls.APACHEVER24:
                        '\t\tRequire all granted\n', }

        version = cls.detectversionfromcmd()
        cfg = "# apache2.conf generated by utility.py:HttpService\n"
        cfg += lockstr[version]
        cfg += """\
PidFile ${APACHE_PID_FILE}
Timeout 300
KeepAlive On
MaxKeepAliveRequests 100
KeepAliveTimeout 5
"""
        cfg += mpmstr[version]
        cfg += """\

<IfModule mpm_prefork_module>
    StartServers          5
    MinSpareServers       5
    MaxSpareServers      10
    MaxClients          150
    MaxRequestsPerChild   0
</IfModule>

<IfModule mpm_worker_module>
    StartServers          2
    MinSpareThreads      25
    MaxSpareThreads      75
    ThreadLimit          64
    ThreadsPerChild      25
    MaxClients          150
    MaxRequestsPerChild   0
</IfModule>

<IfModule mpm_event_module>
    StartServers          2
    MinSpareThreads      25
    MaxSpareThreads      75
    ThreadLimit          64
    ThreadsPerChild      25
    MaxClients          150
    MaxRequestsPerChild   0
</IfModule>

User ${APACHE_RUN_USER}
Group ${APACHE_RUN_GROUP}

AccessFileName .htaccess

<Files ~ "^\.ht">
"""
        cfg += permstr[version]
        cfg += """\
</Files>

DefaultType None

HostnameLookups Off

ErrorLog ${APACHE_LOG_DIR}/error.log
LogLevel warn

#Include mods-enabled/*.load
#Include mods-enabled/*.conf
LoadModule alias_module /usr/lib/apache2/modules/mod_alias.so
LoadModule auth_basic_module /usr/lib/apache2/modules/mod_auth_basic.so
"""
        cfg += authstr[version]
        cfg += """\
LoadModule authz_host_module /usr/lib/apache2/modules/mod_authz_host.so
LoadModule authz_user_module /usr/lib/apache2/modules/mod_authz_user.so
LoadModule autoindex_module /usr/lib/apache2/modules/mod_autoindex.so
LoadModule dir_module /usr/lib/apache2/modules/mod_dir.so
LoadModule env_module /usr/lib/apache2/modules/mod_env.so
LoadModule ssl_module /usr/lib/apache2/modules/mod_ssl.so

Listen 80
Listen 443

LogFormat "%v:%p %h %l %u %t \\"%r\\" %>s %O \\"%{Referer}i\\" \\"%{User-Agent}i\\"" vhost_combined
LogFormat "%h %l %u %t \\"%r\\" %>s %O \\"%{Referer}i\\" \\"%{User-Agent}i\\"" combined
LogFormat "%h %l %u %t \\"%r\\" %>s %O" common
LogFormat "%{Referer}i -> %U" referer
LogFormat "%{User-agent}i" agent

ServerTokens OS
ServerSignature On
TraceEnable Off

<VirtualHost *:80>
	ServerAdmin webmaster@mews
	DocumentRoot /var/www/html
	<Directory />
		Options FollowSymLinks
		AllowOverride None
	</Directory>
	<Directory /var/www/html/>
		Options Indexes FollowSymLinks MultiViews
		AllowOverride None
"""
        cfg += permstr2[version]
        cfg += """\
	</Directory>
	ErrorLog ${APACHE_LOG_DIR}/error.log
	LogLevel warn
	CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>
<VirtualHost *:443>
    SSLEngine on
    SSLVerifyClient none
    SSLCertificateFile "/var/run/apache2/ssl/cert/httpd.crt"
    SSLCertificateKeyFile "/var/run/apache2/ssl/key/httpd.key"
    ServerAdmin webmaster@mews
    DocumentRoot /var/www/html
    <Directory />
        Options FollowSymLinks
        AllowOverride None
    </Directory>
    <Directory /var/www/html/>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
"""
        cfg += permstr2[version]
        cfg += """\
        </Directory>
        ErrorLog ${APACHE_LOG_DIR}/error.log
        LogLevel warn
        CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>
"""
        return cfg

    @classmethod
    def generateenvvars(cls, node, filename, services):
        return """\
# this file is used by apache2ctl - generated by utility.py:HttpService
# these settings come from a default Ubuntu apache2 installation
export APACHE_RUN_USER=www-data
export APACHE_RUN_GROUP=www-data
export APACHE_PID_FILE=/var/run/apache2.pid
export APACHE_RUN_DIR=/var/run/apache2
export APACHE_LOCK_DIR=/var/lock/apache2
export APACHE_LOG_DIR=/var/log/apache2
export LANG=C
export LANG
"""

    @classmethod
    def generatekeygen(cls, node, filename, services):
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control == True:
                continue
            host_if = ifc.addrlist[0].split("/")[0]  # mad h4x
            break

        cfg = """\
#!/bin/sh
# We assume that the node only has one interface, so we assign to the cert the IP of this interface.
openssl req -new -x509 -days 365 -sha1 -newkey rsa:1024 -nodes -keyout /var/run/apache2/ssl/key/httpd.key -out /var/run/apache2/ssl/cert/httpd.crt -subj '/O=CORE/OU=CORE-emu/CN="""
        cfg += host_if
        cfg += """'
# Launch Apache here so we know that cert/key was generated first.
apache2ctl start
"""
        return cfg

class PcapService(UtilService):
    """
    Pcap service for logging packets.
    """
    _name = "pcap"
    _configs = ("pcap.sh",)
    _dirs = ()
    _startindex = 1
    _startup = ("sh pcap.sh start",)
    _shutdown = ("sh pcap.sh stop",)
    _validate = ("pidof tcpdump",)
    _meta = "logs network traffic to pcap packet capture files"

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate a startpcap.sh traffic logging script.
        """
        cfg = """
#!/bin/sh
# set tcpdump options here (see 'man tcpdump' for help)
# (-s snap length, -C limit pcap file length, -n disable name resolution)
DUMPOPTS="-s 12288 -C 2048 -n"

if [ "x$1" = "xstart" ]; then

"""
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control == True:
                cfg += '# '
            redir = "< /dev/null"
            cfg += "tcpdump ${DUMPOPTS} -w %s.%s.pcap -i %s %s &\n" % \
                   (node.name, ifc.name, ifc.name, redir)
        cfg += """

elif [ "x$1" = "xstop" ]; then
    mkdir -p ${SESSION_DIR}/pcap
    mv *.pcap ${SESSION_DIR}/pcap
fi;
"""
        return cfg


class RadvdService(UtilService):
    _name = "radvd"
    _configs = ("/etc/radvd/radvd.conf",)
    _dirs = ("/etc/radvd",)
    _startup = ("radvd -C /etc/radvd/radvd.conf -m logfile -l /var/log/radvd.log",)
    _shutdown = ("pkill radvd",)
    _validate = ("pidof radvd",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        """
        Generate a RADVD router advertisement daemon config file
        using the network address of each interface.
        """
        cfg = "# auto-generated by RADVD service (utility.py)\n"
        for ifc in node.netifs():
            if hasattr(ifc, 'control') and ifc.control == True:
                continue
            prefixes = map(cls.subnetentry, ifc.addrlist)
            if len(prefixes) < 1:
                continue
            cfg += """\
interface %s
{
        AdvSendAdvert on;
        MinRtrAdvInterval 3;
        MaxRtrAdvInterval 10;
        AdvDefaultPreference low;
        AdvHomeAgentFlag off;
""" % ifc.name
            for prefix in prefixes:
                if prefix == "":
                    continue
                cfg += """\
        prefix %s
        {
                AdvOnLink on;
                AdvAutonomous on;
                AdvRouterAddr on;
        };
""" % prefix
            cfg += "};\n"
        return cfg

    @staticmethod
    def subnetentry(x):
        """
        Generate a subnet declaration block given an IPv6 prefix string
        for inclusion in the RADVD config file.
        """
        if x.find(":") >= 0:
            net = Ipv6Prefix(x)
            return str(net)
        else:
            return ""


class AtdService(UtilService):
    """
    Atd service for scheduling at jobs
    """
    _name = "atd"
    _configs = ("startatd.sh",)
    _dirs = ("/var/spool/cron/atjobs", "/var/spool/cron/atspool")
    _startup = ("sh startatd.sh",)
    _shutdown = ("pkill atd",)

    @classmethod
    def generateconfig(cls, node, filename, services):
        return """
#!/bin/sh
echo 00001 > /var/spool/cron/atjobs/.SEQ
chown -R daemon /var/spool/cron/*
chmod -R 700 /var/spool/cron/*
atd
"""


class UserDefinedService(UtilService):
    """
    Dummy service allowing customization of anything.
    """
    _name = "UserDefined"
    _startindex = 50
    _meta = "Customize this service to do anything upon startup."
